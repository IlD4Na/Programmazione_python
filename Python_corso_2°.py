# -*- coding: utf-8 -*-
"""2° Parte Python (ripassato)

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11N9B63qnIAonLDgQtrMGC9HaqhEK1liV

## <mark> Il più comune paradigma di programmazione PROCEDURALE

E' un paradigma di programmazione, in cui la logica del codice viene valutata dall'alto verso il basso (Top-down).

Il codice viene raccolto in funzioni (procedure), blocchi di codice riutilizzabile tramite un alias.

Ad esempio possiamo richiudere dentro ad una funzione il codice che abbiamo scritto per calcolare la media.

poi basta richiamare la funzione che abbiamo salvato come "mean".



```
l = [12, 9, 4, 21, 11, 5, 17]
l_mean = mean(l)  #mean() è la funzione che abbiamo creato

print(l_mean)
```
Come si costruisce la funzione ?

La funzione si costruisce prima di tutto con la keyword "def" seguita dal nome che noi vogliamo dare alla funzione, all'interno delle parentesi tonde passiamo il parametro della funzione. Il valore di ritorno viene poi inserito con la key word return.



```
def sqrt(val):
  return val **(1/2)

# Chiamata alla funzione

sqrt(45)
```
Il processo di invocare la funzione viene chiamata "chiamata a funzione".


```
val_sqrt = sqrt(val)
```
Val è l'argomento ed invece le parentesi è la chiamata a funzione.
Parametro => è un placeholder che si usa durante la definizione della funzione

Argomento => E' l'effettivo valore che andiamo a passare alla funzione

<mark> UNA FUNZIONE DEVE FARE UNA ED UNA SOLTANTO COSA

Le funzioni multi-tasking non devono esistere, secondo il prof.

In ingegneria del software c'è il principio di singola responsabilità SRP che afferma che ogni funzione (o classe) dovrebbe avere una sola responsabilità o motivo di cambiare. Seguendo questo principio, le funzioni sono più semplici, chiare e facili da gestire.

<mark> Come creare una funzione

La definiamo con la keyword "def". Ciò che mettiamo tra parentesi prende il nome di argomento e rappresenta il parametro che noi passiamo alla funzione.

Per invocare la soluzione basta usar eil nome della funzione senza il "def".
"""

def say_hello():
  print("Say Hello")

say_hello()

def say_something(something):
  print("Say " +something)

say_something("Ciao")

"""**<mark>Argomenti di Default**

Se ci dimentichiamo di passare l'argomento otteniamo una eccezione che ci informa del fatto che la funzione say_something manca un parametro. Fortunatamente però Python ci ha dato la possibilità di creare dei parametri che siano di default. Quindi se non passassimo nessun argomento viene usato il parametro di default. Dobbiamo fare solo un'assegnazione all'interno della definizione della funzione.
"""

def say_something(something="something"):
  print("Say "+ something)

say_something()

"""Gli argomenti che contengono un'assegnazione vengono chiamati **<mark>keyword argument.**

Invece quelli che non usano un argomento di default vengono chiamati **<mark>Positional argument.**

Nei positional conta la posizione dell'argomento. Per passare gli argomenti dobbiamo passarli con lo stesso ordine di come abbiamo definito nella funzione.
"""

def say_something(something="something", something_else="something else"):
  print("Say "+ something)
  print("Say "+ something_else)

say_something(something_else ="something", something="Qualcosa di altro")

"""C'è da ricordare che se si usano entrambi sia keyword argument che posizionali i keyword argument vanno passatidopo quelli posizionali, altrimenti Python te li ritorna come eccezioni.

Quindi facciamo passare prima gli argomenti posizionali e solo alla fine quelli che hanno il valore di default.

Vediamo adesso come far ritornare qualcosa ad una funzione con la Return
"""

def say_something(something ="something"):
  say = "say "+something
  return say

say = say_something()

print(say)

"""Questa tipologia di funzioni che ritornano qualcosa vengono chiamate fruitfull function, quelle che non ritornano nulla si chiamano invece void function .

<MARK>**FRUITFUL FUNCTION**

<MARK>**VOID FUNCTION**

Se noi nella funzione prima non mettiamo la parte del "return say" quello che ci ritornerà la funzione sarà il "None".

Quindi quando in una funzione non c'è esplicitato il return allora quella è una funzione Void e ci restituirà None.



```
def stampa_saluto(nome):
    print(f"Ciao, {nome}!")

stampa_saluto("Alice")  # Output: Ciao, Alice!


 Generato da ProfAI - https://prof.profession.ai/
```
In questo esempio la funzione stampa_saluto stampa unmessaggio sullo schermo e non restituisce alcun valore.

"""

def compute_area(b, h):
  return b*h/2

b = float(input("Inserisci la base del triangolo: "))

h = float(input("Inserisci l'altezza del triangolo: "))

area = compute_area(b, h)

print(f"L'area del trignaolo di base {b} e altezza {h} è {area}")

"""Vediamo adesso invece una funzione void."""

def print_shopping_list(shopping_list, owner = "Giuseppe"):
  print("La lista della spesa di", owner)
  for i, entry in enumerate(shopping_list):
    print(f"{i+1}) {entry}")

"""Quando usiamo "enumerate" all'interno di un ciclo for, abbiamo la restituzione di valori (indice, elemento) per ogni iterazione. Questo è molto utile quando si ha bisogno sia dell'indice che del valore dell'elemento corrente dalla lista o da qualsiasi altro iterabile.

Nel contesto del ciclo for, enumerate(shopping_list) restituisce una coppia (i, entry) per ogni elemento della lista shopping_list.
i rappresenta l'indice dell'elemento corrente all'interno della lista. Inizia da 0 e incrementa di 1 ad ogni iterazione.
entry rappresenta l'elemento stesso della lista all'indice i.
Quindi, per ogni iterazione del ciclo, i e entry vengono associati rispettivamente all'indice e all'elemento corrente della lista.


In sintesi, l'uso di enumerate insieme ai due argomenti i ed entry nel ciclo for consente di accedere sia all'indice che al valore di ciascun elemento della lista.
"""

shopping_list = ["tofu", "latte di soia", "riso basmati", "yogurt greco"]


print_shopping_list(shopping_list)

print_shopping_list(owner="Matteo", shopping_list)

"""Vediamo che abbiamo un errore perchè gli argomento posizionali devono essere posizionati prima degli argomenti keyword."""

print_shopping_list(shopping_list, owner="Matteo")

"""# <mark> Esercizi con le Funzioni"""

def calculus_circumference(r):
  return 3.14*(r**2)

r = float(input("Inserisci il raggio del cerchio: "))

cirmumference = calculus_circumference(r)

print(cirmumference)

"""<mark>Esercizio sugli anni bisestili

Ogni 4 anni aggiungiamo un giorno al mese più breve dell'anno, cioèe Febbraio, quest'anno è chiamato bisestile. I criteri utilizzati per definire se un anno è bisestile sono i seguenti:

-L'anno è divisibile per 4, allora è bisestile a meno che:

-L'anno è divisibile per 100, allora non è bisestile a meno che:

-L'anno è divisibile per 400

Scrivere funzione per verificare se un anno è bisestile.


"""

def anno_bisestile(anno):
  if anno % 4 == 0:
    if anno % 100 == 0:
      if anno % 400 == 0:
        return True
      else:
        return False
    else:
      return True
  else:
    return False

#Altro modo per farlo sotto

anno_bisestile(2029)

def is_leap(year):
  leap = False

  if year%4 == 0:
    if year%100 == 0:
      if year%400 == 0:
        leap = True
    else:
      leap = True
  return leap

is_leap(1456)

year = int(input("inserisci l'anno: "))
leap = is_leap(year)

if leap:
  print(f"Il {year} è bisestile")
else:
  print(f"Il {year} non è bisestile")

"""<mark> Esercizi sugli Anagrammi

Definisci una funzione che, prendendo in input due parole, verifica se le due parole sono anagrammi.

Due parole sono angrammi se sono composte esattamente dalle stesse lettere.
"""

def is_anagramma(word1, word2):
  word1 = word1.lower()
  word2 = word2.lower()

  if len(word1) != len(word2):
    return False

  for letter in word1:
    for letter2 in word2:
      if letter == letter2:
        word2 = word2.replace(letter2, "", 1)
        break
  if word2 == "":
    return True
  else:
    return False

is_anagramma("cane", "enca")

"""In questo codice sopra viene utilizzato un ciclo annidato ovvero un ciclo for all'interno di un altro ciclo for.


Il ciclo più esterno for letter in word1 itera su ogni lettera di word1.
Il ciclo interno for letter2 in word2 itera su ogni lettera di word2 per ogni iterazione del ciclo esterno.
All'interno del ciclo interno, viene verificato se letter (dal ciclo esterno) è uguale a letter2 (dal ciclo interno).
Se viene trovata una corrispondenza, la lettera letter2 viene rimossa da word2 usando il metodo replace con il terzo argomento 1 che indica di sostituire solo la prima occorrenza. Questo è importante per gestire correttamente le lettere duplicate.
Il break interrompe il ciclo interno non appena viene trovata una corrispondenza, per evitare di rimuovere più di una lettera corrispondente.


Comunque in questo esercizio si potrebbe confrontare le versioni ordinate delle due parole o utilizzare un contatore per verificare la frequenza delle lettere.

**<mark> Versione alternativa**
"""

def is_anagramma(word1, word2):
    # Convertiamo entrambe le parole in minuscolo per ignorare le differenze di maiuscole/minuscole
    word1 = word1.lower()
    word2 = word2.lower()

    # Se le lunghezze sono diverse, non possono essere anagrammi
    if len(word1) != len(word2):
        return False

    # Ordiniamo entrambe le parole
    sorted_word1 = sorted(word1)
    sorted_word2 = sorted(word2)

    # Confrontiamo le parole ordinate
    return sorted_word1 == sorted_word2

# Esempi di utilizzo
print(is_anagramma("strani", "nastri"))  # Output: True
print(is_anagramma("carino", "canori"))  # Output: True
print(is_anagramma("senatori", "estranio"))  # Output: True
print(is_anagramma("ciao", "miao"))  # Output: False

"""<mark> Validazione di indirizzi email

Realizziamo una funzione che, prendendo in input una lista di indirizzi email, ritorni una nuova lista degli indirizzi email validi ordinati alfabeticamente.

Un indirizzo email è valido se:

-ha il formato nomeutente@dominio.estensione.

-Il nome utente contiene soltanto lettere, numeri, lineette (-) e trattini bassi (_)

-Il dominio contiene soltanto lettere e numeri.

-La lunghezza massima dell'estensione è 3 caratteri.
"""

def validate_email(email_list):
  valid_email = []

  for email in email_list:
    if "@" in email and "." in email:
      name, domain = email.split("@")
      extension = domain.split(".")

      if name.isalnum() and extension[0].isalpha() and len(extension[1]) <= 3:
        valid_email.append(email)
  valid_email.sort()
  return valid_email

email_list =  ["adrian25@gmail.com", "drona8956gmail.com", "martina_25@gmai.torca", "Marioossi98@gmail.com", "Zebra87@yahoo.it"]

validate_email(email_list)

#altro metodo
#Questa è la prima funzione che ci permette di vedere se l'email è valida

def validate_email(email):
  parts = email.split("@")

  if lent(parts)!=2:
    return False


  name, parts = parts

  parts = parts.split(".")

  if len(parts)!=2:
    return False

    domain, ext = parts


  if not name.replace("-","").replace("_","").isalnum():
    return False

  if not domain.isalnum():
    return False

  if len(ext)> 3:
    return False


  return True